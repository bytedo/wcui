<template>
  <div class="container">
    <div class="wrapper"><slot /></div>
    <div class="is-horizontal"><span class="thumb"></span></div>
    <div class="is-vertical"><span class="thumb"></span></div>
  </div>
</template>

<style lang="scss">
:host {
  display: block;
  width: 100%;
  height: 100%;

  .container {
    overflow: hidden;
    position: relative;
    width: 100%;
    height: 100%;
  }

  .wrapper {
    overflow: auto;
    position: relative;
    width: calc(100% + 18px);
    height: calc(100% + 18px);
    padding: 0 18px 18px 0;
  }
}

/* 横向 */

.is-horizontal,
.is-vertical {
  visibility: hidden;
  position: absolute;
  display: flex;
  justify-content: flex-end;
  z-index: 10240;
  opacity: 0;
  user-select: none;
  transition: opacity 0.3s linear, visibility 0.3s linear;

  .thumb {
    display: block;
    border-radius: 5px;
    background: rgba(44, 47, 53, 0.25);
    cursor: default;
    transition: width 0.1s linear, height 0.1s linear;

    &:hover {
      background: rgba(44, 47, 53, 0.5);
    }
  }
}

.is-horizontal {
  flex-direction: column;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 10px;

  .thumb {
    width: 0;
    height: 6px;

    &:hover {
      height: 10px;
    }
  }
}

/* 纵向 */
.is-vertical {
  top: 0;
  right: 0;
  width: 10px;
  height: 100%;

  .thumb {
    width: 6px;
    height: 0;

    &:hover {
      width: 10px;
    }
  }
}

:host(:hover) {
  .is-horizontal,
  .is-vertical {
    visibility: visible;
    opacity: 1;
  }
}

:host([axis='x']) {
  .wrapper {
    overflow-y: hidden;
  }
  .is-vertical {
    display: none;
  }
}
:host([axis='y']) {
  .wrapper {
    overflow-x: hidden;
  }
  .is-horizontal {
    display: none;
  }
}
:host([disabled]) {
  .wrapper {
    overflow: hidden;
  }
  .is-vertical,
  .is-horizontal {
    display: none;
  }
}
</style>

<script>
import $ from '../utils'

const AXIS_LIST = ['x', 'y', 'xy']

/*  */
export default class Scroll {
  props = {
    axis: 'xy', // 滚动方向, 默认x轴和y轴都可以滚动
    delay: 1000, // 节流防抖延迟
    distance: 1 // 触发距离阀值, 单位像素
  }

  state = {
    width: 0, // 滚动组件的真实宽度
    height: 0, // 滚动组件的真实高度
    scrollX: 0, // 滚动组件的滚动宽度
    scrollY: 0, // 滚动组件的滚动高度
    xBar: 0, // 横轴长度
    yBar: 0, // 纵轴长度
    thumbX: 0, //横向条滚动距离
    thumbY: 0 // 纵向条滚动距离
  }

  __init__() {
    /* render */
    var elem = this.root.children[1]
    this.__BOX__ = elem.children[0]
    this.__X__ = elem.children[1].children[0]
    this.__Y__ = elem.children[2].children[0]
    this.__last__ = 0
  }

  get scrollTop() {
    return this.__BOX__.scrollTop
  }

  set scrollTop(n) {
    n = +n
    if (n === n) {
      this.__BOX__.scrollTop = n
    }
  }

  get scrollLeft() {
    return this.__BOX__.scrollLeft
  }

  set scrollLeft(n) {
    n = +n
    if (n === n) {
      this.__BOX__.scrollLeft = n
    }
  }

  get scrollHeight() {
    return this.__BOX__.scrollHeight
  }

  get scrollWidth() {
    return this.__BOX__.scrollWidth
  }

  _fetchScrollX(moveX) {
    var { scrollX, width, xBar } = this.state

    if (moveX < 0) {
      moveX = 0
    } else if (moveX > width - xBar) {
      moveX = width - xBar
    }
    this.__BOX__.scrollLeft = (scrollX - width) * (moveX / (width - xBar))
    this.__X__.style.transform = `translateX(${moveX}px)`

    return moveX
  }

  _fetchScrollY(moveY) {
    var { scrollY, height, yBar } = this.state

    if (moveY < 0) {
      moveY = 0
    } else if (moveY > height - yBar) {
      moveY = height - yBar
    }

    this.__BOX__.scrollTop = (scrollY - height) * (moveY / (height - yBar))
    this.__Y__.style.transform = `translateY(${moveY}px)`
    return moveY
  }

  _fireReachEnd(action = 'reach-bottom') {
    var { delay } = this.props
    var { scrollY, height } = this.state
    var top = this.__BOX__.scrollTop
    var now = Date.now()

    if (now - this.__last__ > delay) {
      if (action === 'reach-bottom') {
        if (height + top < scrollY) {
          return
        }
      } else {
        if (top > 0) {
          return
        }
      }

      this.__last__ = now
      this.dispatchEvent(new CustomEvent(action))
    }
  }

  mounted() {
    // 初始化滚动条的位置和长度
    this._initFn = $.catch(this, 'ready', ev => {
      // 需要减去因为隐藏原生滚动条修正的18像素
      var width = this.__BOX__.clientWidth - 18
      var height = this.__BOX__.clientHeight - 18
      var scrollX = this.__BOX__.scrollWidth - 18
      var scrollY = this.__BOX__.scrollHeight - 18

      var yBar = (height * (height / scrollY)) >> 0 // 滚动条的高度
      var xBar = (width * (width / scrollX)) >> 0 // 滚动条的宽度

      if (yBar < 50) {
        yBar = 50
      }
      if (xBar < 50) {
        xBar = 50
      }

      // 100%或主体高度比滚动条还短时不显示
      if (xBar >= width) {
        xBar = 0
      }
      if (yBar >= height) {
        yBar = 0
      }

      this.state.height = height
      this.state.width = width
      this.state.scrollY = scrollY
      this.state.scrollX = scrollX
      this.state.yBar = yBar
      this.state.xBar = xBar

      this.__X__.style.width = xBar + 'px'
      this.__Y__.style.height = yBar + 'px'
    })

    // 鼠标滚动事件
    this._scrollFn = $.bind(this.__BOX__, 'scroll', ev => {
      // 拖拽时忽略滚动事件
      if (this._active) {
        return
      }
      var { axis } = this.props
      var {
        xBar,
        yBar,
        thumbX,
        thumbY,
        scrollY,
        scrollX,
        width,
        height
      } = this.state
      var currTop = this.__BOX__.scrollTop
      var currLeft = this.__BOX__.scrollLeft

      // x轴 y轴 都为0时, 不作任何处理
      if (xBar === 0 && yBar === 0) {
        return
      }

      //
      if (axis === 'y' || axis === 'xy') {
        if (yBar) {
          // 修正滚动条的位置
          // 滚动比例 y 滚动条的可移动距离
          let fixedY = (currTop / (scrollY - height)) * (height - yBar)

          fixedY = fixedY >> 0

          if ((fixedY === 0 || height - yBar === fixedY) && fixedY === thumbY) {
            return
          }

          this.state.thumbY = fixedY
          this.__Y__.style.transform = `translateY(${fixedY}px)`

          if (Math.abs(fixedY - thumbY) > this.props.distance) {
            this._fireReachEnd(fixedY > thumbY ? 'reach-bottom' : 'reach-top')
          }
        }
      }

      if (axis === 'x' || axis === 'xy') {
        if (xBar) {
          // 修正滚动条的位置
          // 滚动比例 x 滚动条的可移动距离
          let fixedX = (currLeft / (scrollX - width)) * (width - xBar)

          fixedX = fixedX >> 0

          if ((fixedX === 0 || width - xBar === fixedX) && fixedX === thumbX) {
            return
          }

          this.state.thumbX = fixedX
          this.__X__.style.transform = `translateX(${fixedX}px)`
        }
      }

      this.dispatchEvent(new CustomEvent('scroll'))
    })

    let startX,
      startY,
      moveX,
      moveY,
      mousemoveFn = ev => {
        let { thumbY, thumbX } = this.state
        if (startX !== undefined) {
          moveX = this._fetchScrollX(thumbX + ev.pageX - startX)
        }

        if (startY !== undefined) {
          moveY = this._fetchScrollY(thumbY + ev.pageY - startY)
        }
      },
      mouseupFn = ev => {
        if (Math.abs(ev.pageY - startY) > this.props.distance) {
          this._fireReachEnd(ev.pageY > startY ? 'reach-bottom' : 'reach-top')
        }
        startX = undefined
        startY = undefined
        this.state.thumbX = moveX || 0
        this.state.thumbY = moveY || 0
        delete this._active
        $.unbind(document, 'mousemove', mousemoveFn)
        $.unbind(document, 'mouseup', mouseupFn)
      }

    this._yBarFn = $.bind(this.__Y__, 'mousedown', ev => {
      startY = ev.pageY

      this._active = true

      $.bind(document, 'mousemove', mousemoveFn)
      $.bind(document, 'mouseup', mouseupFn)
    })

    this._xBarFn = $.bind(this.__X__, 'mousedown', ev => {
      startX = ev.pageX
      this._active = true

      $.bind(document, 'mousemove', mousemoveFn)
      $.bind(document, 'mouseup', mouseupFn)
    })

    this.__observer = new MutationObserver(this._initFn)
    this.__observer.observe(this, {
      childList: true,
      subtree: true,
      attributeFilter: ['style']
    })

    this._initFn(new Event('mounted'))
  }

  unmounted() {
    this.__observer.disconnect()

    $.unbind(this.__X__, 'mousedown', this._xBarFn)
    $.unbind(this.__Y__, 'mousedown', this._yBarFn)
    $.unbind(this, 'ready', this._initFn)
    $.unbind(this.__BOX__, 'scroll', this._scrollFn)
  }

  watch() {
    switch (name) {
      case 'axis':
        if (val) {
          if (AXIS_LIST.includes(val)) {
            this.props.axis = val
          } else {
            this.removeAttribute(name)
          }
        } else {
          this.props.axis = 'xy'
        }
        break

      case 'delay':
        this.props.delay = +val || 1000
        break

      case 'distance':
        this.props.distance = +val || 1
        break
    }
  }
}
</script>
